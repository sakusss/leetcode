# 面试问题 第四范式
# 要求线性复杂度，也就是说不能使用排序（排序最优也就是O（nlogn）
# 我们遍历这个数组的时候，定义一个count用来计数，
# 这个超过一半的数，它遇到自己就给count加1，
# 遇到不是自己的数，就给count减1，最后会怎样呢，
# count肯定大于0呐，因为这个数的个数超过一半。
# 好，进一步的，我们先随便找个数当这个老大（个数超过一半），
# 如果它的个数不超过一半，就会在相消中时count为0，那么就把它换掉，
# 最后剩下的那个就是，个数超过一半的那个数了。

class Solution:
    def majorityElement(self, nums):
        count = 1
        
        max = nums[0]

        for j in nums[1:]:
            
            if count == 0:
                
                max = j
                
                count += 1

            else:
                
                if max == j: count += 1
                    
                else : count -= 1
        
        return max
# 没有太想清楚为什么直接换就可以
# 相当于前面都是不相同元素的配对，众数配对肯定是落单的
# 所以从后面继续进行配对
# 还是不是特别熟悉，用count进行判断。
# 用相消法都能消出那个数，跟那个用异或消出只出现一次的数（其它的数都是成对的，就是都恰好有两个）是不是异曲同工呐，嗯还是扯得有点远。
        
