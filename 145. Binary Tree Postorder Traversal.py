-----------------------------递归----------------------------------
class Solution:
    def recursive_post(self,root,res):
        if root:
            self.recursive_post(root.left,res)
            self.recursive_post(root.right,res)
            res.append(root.val)
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res =[]
        self.recursive_post(root,res)
        return res
        
时间复杂度O(N),空间复杂度O（logn）

--------------------迭代----------------------------------------------
先找到右然后回溯回去，回到父节点。整个后序遍历可以分为若干个片段，每一个片段，分别起始于通路上的一个节点，并包括三步：访问该节点，遍历以其
右兄弟为根的子树，以及向上回溯至其父节点，并转入下一个片段。
我们需要维护当前遍历的cur指针和前一个遍历的pre指针来追溯当前的情况。具体为：
1.如果pre的左孩子或者右孩子是cur，那么说明遍历在往下走，按访问顺序继续，即如果有左孩子，则是左孩子进栈，否则如果有右孩子，则是右孩子进栈，如果左右孩子都没有，
则说明该孩子是叶子节点，可以直接访问并将结点出栈了
2.如果反过来，cur的左孩子是pre，则说明已经在回溯往上走了，但是我们知道后序遍历要左右孩子走完才可以访问自己，所以这里如果有右孩子还需要把右孩子进栈，
否说明已经到自己了，可以访问并且出栈了。
3.如果cur的右孩子是pre，那么说明左右孩子都已经访问结束了，可以轮到自己了，访问并且出栈即可。

----------------------------------------------------------------------------------------------
使用一个栈。分几个步骤：

　　　　　一，将根节点入栈，并将根节点的孩子入栈，入栈顺序为：先入右孩子，再入左孩子，顺序不能错。因为这样在弹栈时的顺序就是后序遍历的顺序了。如果左孩子还有左孩子或者右孩子，那么继续按先右后左的顺序入栈。那么上面这棵树开始的入栈顺序是：1，3，2。由于2不存在左右孩子，停止入栈。

　　　　   二，由于2没有左右孩子，遍历2并将2弹出，同时使用prev记录下2这个节点。

　　　　   三，2出栈后，栈为{1，3}，此时3在栈顶，由于3存在左右孩子，按顺序入栈，此时栈为{1，3，5，4}。

　　　　   四，将4和5遍历并出栈，此时prev指向5，栈为{1，3}。prev的作用是什么呢？用来判断prev是否为栈顶元素的孩子，如果是，则说明子树的孩子已经遍历完成，需要遍历树根了。以上树为例：4和5出栈后，prev指向5，而5是栈顶元素3的孩子，说明孩子已经遍历完毕，则遍历3然后弹出3即可，即完成了子树{3，4，5}的后序遍历。

　　　　   五，此时栈为{1}，为树根，而左右子树都遍历完了，最后遍历树根并弹出即可。
class Solution:
    def iterative_post(self,root,res):
        stack=[]
        pre = None
        if root:
            stack.append(root)
            while stack:
                cur = stack[len(stack)-1]
                if (cur.left == None and cur.right==None) or (pre and (pre == cur.left or pre==cur.right)):
                    res.append(cur.val)
                    stack.pop()
                    pre = cur
                else:
                    if cur.right:stack.append(cur.right)
                    if cur.left :stack.append(cur.left)
        return res
                
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        res =[]
        self.iterative_post(root,res)
        return res



算法时间复杂度也是O(n)，空间复杂度是栈的大小O(logn)。
---------------------------------------------------------
对于任一节点P，

1）先将节点P入栈；

2）若P不存在左孩子和右孩子，或者P存在左孩子或右孩子，但左右孩子已经被输出，则可以直接输出节点P，并将其出栈，将出栈节点P标记为上一个输出的节点，再将此时的栈顶结点设为当前节点；

3）若不满足2）中的条件，则将P的右孩子和左孩子依次入栈，当前节点重新置为栈顶结点，之后重复操作2）；

4）直到栈空，遍历结束。
首先，设置两个指针：Cur指针指向当前访问的节点，它一直指向栈顶节点，每次出栈一个节点后，将其重新置为栈顶结点，Pre节点指向上一个访问的节点；


---------------------morris------------------------------------
最后介绍Morris遍历方法，这个方法不需要为每个节点额外分配指针指向其前驱和后继结点，而是利用叶子节点中的右空指针指向中序遍历下的后继节点就可以了，所以优势在于不需要额外空间。不过同样相比于Binary Tree Inorder Traversal和Binary Tree Preorder Traversal，后序遍历的情况要复杂得多，因为后序遍历中一直要等到孩子结点访问完才能访问自己，需要一些技巧来维护。

在这里，我们需要创建一个临时的根节点dummy，把它的左孩子设为树的根root。同时还需要一个subroutine来倒序输出一条右孩子路径上的结点。跟迭代法一样我们需要维护cur指针和pre指针来追溯访问的结点。具体步骤是重复以下两步直到结点为空：
1. 如果cur指针的左孩子为空，那么cur设为其右孩子。
2. 否则，在cur的左子树中找到中序遍历下的前驱结点pre（其实就是左子树的最右结点）。接下来分两种子情况：
（1）如果pre没有右孩子，那么将他的右孩子接到cur。将cur更新为它的左孩子。
（2）如果pre的右孩子已经接到cur上了，说明这已经是回溯访问了，可以处理访问右孩子了，倒序输出cur左孩子到pre这条路径上的所有结点，并把pre的右孩子重新设为空（结点已经访问过了，还原现场）。最后将cur更新为cur的右孩子。
空间复杂度同样是O(1)，而时间复杂度也还是O(n)，倒序输出的过程只是加大了常数系数，并没有影响到时间的量级。如果对这个复杂度结果不是很熟悉的朋友，可以先看看Binary Tree Inorder Traversal中的分析，在那个帖子中讲得比较详细。实现的代码如下：

##https://blog.csdn.net/linhuanmars/article/details/22009351
